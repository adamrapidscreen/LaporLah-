# E4-S3: Build Status Update UI

## Description
Add a status update section to the report detail page that allows the report creator or admin to advance the status forward, and any authenticated user to propose "Resolved". Wire the UI to a new `updateReportStatus` server action with authorization checks.

## Dependencies
- Stories: E4-S1 (report detail page), E4-S2 (status stepper), E3-S4 (reports actions file)
- Files: `src/app/report/[id]/page.tsx`, `src/components/reports/status-stepper.tsx`, `src/lib/actions/reports.ts`, `src/lib/constants/statuses.ts`

## Tasks
1. `src/components/reports/status-update.tsx`: Create Client Component with a dropdown or button group that shows the next valid status transition. Creator/admin see forward transitions (Open→Acknowledged→In Progress). Any authenticated user sees "Mark as Resolved" button when status is `in_progress`. Show current status context. Use optimistic update pattern.
2. `src/lib/actions/reports.ts`: Add `updateReportStatus` server action — validate status transition with Zod, check auth (creator or admin for forward transitions, any authenticated user for proposing resolved), UPDATE the report's `status` column, call `notify_followers`, and `revalidatePath`.
3. `src/app/report/[id]/page.tsx`: Integrate the status update component into the detail page, passing the report data and current user info.

## Implementation Notes

### Status Update Component
```tsx
// src/components/reports/status-update.tsx
'use client';

import { useTransition } from 'react';
import { Button } from '@/components/ui/button';
import { updateReportStatus } from '@/lib/actions/reports';
import { STATUS_FLOW, statusConfig, getStatusIndex, type ReportStatus } from '@/lib/constants/statuses';

interface StatusUpdateProps {
  reportId: string;
  currentStatus: ReportStatus;
  isCreatorOrAdmin: boolean;
  isAuthenticated: boolean;
}

export function StatusUpdate({
  reportId,
  currentStatus,
  isCreatorOrAdmin,
  isAuthenticated,
}: StatusUpdateProps) {
  const [isPending, startTransition] = useTransition();
  const currentIndex = getStatusIndex(currentStatus);

  function getNextStatus(): ReportStatus | null {
    // Creator/admin can advance forward (up to in_progress)
    if (isCreatorOrAdmin && currentIndex < 3) {
      return STATUS_FLOW[currentIndex + 1];
    }
    // Any auth user can propose resolved when in_progress
    if (isAuthenticated && currentStatus === 'in_progress') {
      return 'resolved';
    }
    return null;
  }

  const nextStatus = getNextStatus();
  if (!nextStatus) return null;

  const nextConfig = statusConfig[nextStatus];

  function handleUpdate() {
    startTransition(async () => {
      const result = await updateReportStatus(reportId, nextStatus!);
      if (result?.error) {
        // show error toast
      }
    });
  }

  return (
    <Button onClick={handleUpdate} disabled={isPending} variant="outline" size="sm">
      {isPending ? 'Updating...' : `→ ${nextConfig.labelMs}`}
    </Button>
  );
}
```

### Server Action
```tsx
// Addition to src/lib/actions/reports.ts
import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import { createServerClient } from '@/lib/supabase/server';
import { STATUS_FLOW, type ReportStatus } from '@/lib/constants/statuses';

const updateStatusSchema = z.object({
  reportId: z.string().uuid(),
  newStatus: z.enum(['acknowledged', 'in_progress', 'resolved', 'closed']),
});

export async function updateReportStatus(reportId: string, newStatus: ReportStatus) {
  const parsed = updateStatusSchema.safeParse({ reportId, newStatus });
  if (!parsed.success) return { error: 'Invalid input' };

  const supabase = await createServerClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { error: 'Not authenticated' };

  // Fetch report to check authorization
  const { data: report } = await supabase
    .from('reports')
    .select('user_id, status')
    .eq('id', reportId)
    .single();

  if (!report) return { error: 'Report not found' };

  const currentIndex = STATUS_FLOW.indexOf(report.status as ReportStatus);
  const newIndex = STATUS_FLOW.indexOf(newStatus);

  // Authorization: creator/admin for forward, any auth for resolved
  const isCreatorOrAdmin = report.user_id === user.id; // TODO: add admin check
  if (newStatus !== 'resolved' && !isCreatorOrAdmin) {
    return { error: 'Not authorized' };
  }
  if (newIndex <= currentIndex) {
    return { error: 'Invalid status transition' };
  }

  // Update status
  const { error } = await supabase
    .from('reports')
    .update({ status: newStatus })
    .eq('id', reportId);

  if (error) return { error: 'Failed to update status' };

  // Notify followers (handled in E4-S4)
  revalidatePath(`/report/${reportId}`);
  return { success: true };
}
```

### Valid Status Transitions
- `open` → `acknowledged` (creator/admin only)
- `acknowledged` → `in_progress` (creator/admin only)
- `in_progress` → `resolved` (any authenticated user)
- `resolved` → `closed` (creator/admin only, handled later)

## Acceptance Criteria
- [ ] Status update button appears for authorized users
- [ ] Creator/admin can advance status forward (open → acknowledged → in_progress)
- [ ] Any authenticated user can propose "Resolved" when status is `in_progress`
- [ ] Unauthorized users do not see the update button
- [ ] Server action validates status transition (cannot skip steps or go backward)
- [ ] Server action checks authentication and authorization
- [ ] Zod schema validates input (reportId as UUID, newStatus as valid enum)
- [ ] UI shows loading state during transition (`useTransition`)
- [ ] Path is revalidated after successful update
- [ ] Error responses are returned (not thrown) following `{ error }` pattern
