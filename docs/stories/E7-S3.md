# E7-S3: Implement Resolution Check Logic

## Description
Add the `checkResolution` function to `src/lib/actions/votes.ts` that evaluates confirmation votes against resolution thresholds. This function handles three scenarios: auto-close when ≥3 confirmed votes, revert to in_progress when majority votes "not_yet", and timeout handling when the 72-hour window expires. It awards bonus points, updates badges, and notifies followers on state transitions.

## Dependencies
- Stories: E7-S2 (castVote server action), E4-S4 (resolved_by tracking), E1-S2 (DB functions: award_points, check_and_award_badges, notify_followers)
- Files: `src/lib/actions/votes.ts`, `supabase/migrations/003_create_functions.sql`

## Tasks
1. `src/lib/actions/votes.ts`: Add `checkResolution(reportId: string)` function with the following logic:
   - Fetch the report (status, resolved_at, user_id, resolved_by) and all confirmations for this report
   - Count confirmed vs not_yet votes
   - **If confirmed ≥ 3**: UPDATE report status to 'closed', award 25 pts to report creator (`user_id`), award 15 pts to resolver (`resolved_by`), call `check_and_award_badges` for both users, call `notify_followers` with type 'status_change'
   - **If not_yet > confirmed (majority)**: UPDATE report status back to 'in_progress', clear `resolved_at`, call `notify_followers` with revert notification
   - **Timeout path** (72h expired): If ≥1 confirmed and 0 not_yet → auto-close (same as ≥3 path); if 0 votes → revert to 'in_progress'
2. `src/app/report/[id]/page.tsx`: Call `checkResolution` on page load (SSR) when report status is 'resolved' and 72h has elapsed — this handles the timeout check without a cron job

## Implementation Notes

### Resolution Check Function
```ts
// Add to src/lib/actions/votes.ts

async function checkResolution(reportId: string) {
  const supabase = await createServerClient();

  // Fetch report details — use user_id (creator) and resolved_by (resolver)
  const { data: report } = await supabase
    .from('reports')
    .select('id, status, resolved_at, user_id, resolved_by')
    .eq('id', reportId)
    .single();

  if (!report || report.status !== 'resolved') return;

  // Fetch all votes for this report
  const { data: votes } = await supabase
    .from('confirmations')
    .select('vote')
    .eq('report_id', reportId);

  const confirmed = votes?.filter(v => v.vote === 'confirmed').length ?? 0;
  const notYet = votes?.filter(v => v.vote === 'not_yet').length ?? 0;

  const resolvedAt = new Date(report.resolved_at);
  const now = new Date();
  const hoursElapsed = (now.getTime() - resolvedAt.getTime()) / (1000 * 60 * 60);
  const isExpired = hoursElapsed >= 72;

  // Scenario 1: ≥3 confirmed votes → close
  if (confirmed >= 3) {
    await closeReport(supabase, report);
    return;
  }

  // Scenario 2: Majority not_yet → revert
  if (notYet > confirmed && notYet > 0) {
    await revertReport(supabase, report);
    return;
  }

  // Scenario 3: Timeout checks
  if (isExpired) {
    if (confirmed >= 1 && notYet === 0) {
      // Auto-close: at least 1 confirmed, no objections
      await closeReport(supabase, report);
    } else if (confirmed === 0 && notYet === 0) {
      // No votes at all → revert
      await revertReport(supabase, report);
    }
  }
}

async function closeReport(supabase: any, report: any) {
  await supabase
    .from('reports')
    .update({ status: 'closed', updated_at: new Date().toISOString() })
    .eq('id', report.id);

  // Award 25 pts to report creator (user_id)
  await supabase.rpc('award_points', {
    p_user_id: report.user_id,
    p_action: 'report_closed',
    p_points: 25,
    p_report_id: report.id,
  });

  // Award 15 pts to resolver (resolved_by — set in E4-S4 when status was proposed as resolved)
  if (report.resolved_by && report.resolved_by !== report.user_id) {
    await supabase.rpc('award_points', {
      p_user_id: report.resolved_by,
      p_action: 'resolution_confirmed',
      p_points: 15,
      p_report_id: report.id,
    });

    await supabase.rpc('check_and_award_badges', { p_user_id: report.resolved_by });
  }

  await supabase.rpc('check_and_award_badges', { p_user_id: report.user_id });

  // Notify followers
  await supabase.rpc('notify_followers', {
    p_report_id: report.id,
    p_type: 'status_change',
    p_message: 'Laporan telah ditutup selepas pengesahan komuniti',
    p_exclude_user: null,
  });
}

async function revertReport(supabase: any, report: any) {
  await supabase
    .from('reports')
    .update({
      status: 'in_progress',
      resolved_at: null,
      updated_at: new Date().toISOString(),
    })
    .eq('id', report.id);

  // Notify followers of revert
  await supabase.rpc('notify_followers', {
    p_report_id: report.id,
    p_type: 'status_change',
    p_message: 'Laporan dikembalikan ke "Dalam Proses" — komuniti belum berpuas hati',
    p_exclude_user: null,
  });
}
```

### Timeout Check on Page Load
```tsx
// In src/app/report/[id]/page.tsx — after fetching report
if (report.status === 'resolved' && report.resolved_at) {
  const hoursElapsed = (Date.now() - new Date(report.resolved_at).getTime()) / (1000 * 60 * 60);
  if (hoursElapsed >= 72) {
    const { checkResolution } = await import('@/lib/actions/votes');
    await checkResolution(report.id);
    // Re-fetch report after potential state change
  }
}
```

### Key Design Decisions
- No cron job needed — timeout is checked lazily on page load
- `user_id` is the report creator (receives 25 pts on close)
- `resolved_by` tracks who proposed the resolution (receives 15 pts on close, set in E4-S4)
- Resolver points are awarded HERE at confirmation time, NOT in E4-S4 at propose time (prevents double-payment)
- If resolver is the same as creator, only 25 pts are awarded (no self-awarding of 15 pts)
- Helper functions `closeReport` and `revertReport` are not exported (internal only)
- All RPC calls use the service role client patterns established in E1-S2

## Acceptance Criteria
- [ ] `checkResolution` function exists in `src/lib/actions/votes.ts`
- [ ] ≥3 confirmed votes triggers report closure (status → 'closed')
- [ ] Report creator (`user_id`) receives 25 points when report is closed
- [ ] Resolver (`resolved_by`) receives 15 points when resolution is confirmed
- [ ] Resolver points are NOT duplicated (only awarded here, not in E4-S4)
- [ ] If resolver === creator, only 25 pts are awarded (no double-dip)
- [ ] `check_and_award_badges` is called for both creator and resolver
- [ ] Majority "not_yet" votes reverts report to 'in_progress' and clears `resolved_at`
- [ ] Followers are notified on both close and revert via `notify_followers`
- [ ] 72h timeout with ≥1 confirmed and 0 not_yet → auto-close
- [ ] 72h timeout with 0 votes → revert to 'in_progress'
- [ ] Timeout check is triggered on page load (no cron dependency)
- [ ] Page re-fetches report data after timeout-triggered state change
