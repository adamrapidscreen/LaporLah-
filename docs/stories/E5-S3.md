# E5-S3: Implement Comment Server Action

## Description
Create the `addComment` server action that validates input with Zod, checks authentication and ban status, verifies comments are not locked, inserts the comment, awards points, updates streaks, checks badges, notifies followers, and revalidates the page.

## Dependencies
- Stories: E5-S2 (comment form), E1-S2 (DB functions: award_points, update_streak, check_and_award_badges, notify_followers)
- Files: `src/components/comments/comment-form.tsx`, database functions

## Tasks
1. `src/lib/actions/comments.ts`: Create the `addComment` server action with full validation, authorization, and side effects chain.

## Implementation Notes

### addComment Server Action
```tsx
// src/lib/actions/comments.ts
'use server';

import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import { createServerClient } from '@/lib/supabase/server';

const addCommentSchema = z.object({
  reportId: z.string().uuid(),
  content: z.string().min(1, 'Comment cannot be empty').max(1000, 'Comment too long'),
});

export async function addComment(reportId: string, content: string) {
  // 1. Validate input
  const parsed = addCommentSchema.safeParse({ reportId, content });
  if (!parsed.success) {
    return { error: parsed.error.errors[0].message };
  }

  const supabase = await createServerClient();

  // 2. Check authentication
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { error: 'Not authenticated' };

  // 3. Check if user is banned
  const { data: profile } = await supabase
    .from('users')
    .select('is_banned')
    .eq('id', user.id)
    .single();

  if (profile?.is_banned) return { error: 'Your account is suspended' };

  // 4. Check if comments are locked on this report
  const { data: report } = await supabase
    .from('reports')
    .select('comments_locked')
    .eq('id', reportId)
    .single();

  if (!report) return { error: 'Report not found' };
  if (report.comments_locked) return { error: 'Comments are locked on this report' };

  // 5. Insert comment
  const { error: insertError } = await supabase
    .from('comments')
    .insert({
      report_id: reportId,
      user_id: user.id,
      content: parsed.data.content,
    });

  if (insertError) return { error: 'Failed to add comment' };

  // 6. Award points (5 pts for commenting)
  await supabase.rpc('award_points', {
    p_user_id: user.id,
    p_action: 'comment',
    p_points: 5,
    p_report_id: reportId,
  });

  // 7. Update streak
  await supabase.rpc('update_streak', {
    p_user_id: user.id,
  });

  // 8. Check and award badges
  await supabase.rpc('check_and_award_badges', {
    p_user_id: user.id,
  });

  // 9. Notify followers (exclude the commenter)
  await supabase.rpc('notify_followers', {
    p_report_id: reportId,
    p_type: 'new_comment',
    p_message: `Komen baru pada laporan / New comment on report`,
    p_exclude_user: user.id,
  });

  // 10. Revalidate the report page
  revalidatePath(`/report/${reportId}`);

  return { success: true };
}
```

### Validation Schema Details
```tsx
const addCommentSchema = z.object({
  reportId: z.string().uuid(),
  content: z
    .string()
    .min(1, 'Comment cannot be empty')
    .max(1000, 'Comment too long (max 1000 characters)')
    .transform((val) => val.trim()),
});
```

### Action Flow (Sequential)
1. **Validate** — Zod schema (reportId UUID, content 1-1000 chars)
2. **Authenticate** — `supabase.auth.getUser()`, return error if not logged in
3. **Check banned** — Query `users.is_banned`, return error if true
4. **Check locked** — Query `reports.comments_locked`, return error if true
5. **Insert** — INSERT into `comments` table
6. **Award points** — `award_points(user_id, 'comment', 5, report_id)`
7. **Update streak** — `update_streak(user_id)`
8. **Check badges** — `check_and_award_badges(user_id)`
9. **Notify** — `notify_followers(report_id, 'new_comment', message, exclude_user)`
10. **Revalidate** — `revalidatePath('/report/[id]')`

### Error Handling Pattern
- Return `{ error: string }` on any failure — never throw
- Side effects (steps 6-9) should not block the response; log errors but don't fail
- Only the insert (step 5) should cause an error return

### Points System
- Commenting awards 5 points to the commenter
- Action key: `'comment'`

## Acceptance Criteria
- [ ] `addComment` validates input with Zod (reportId as UUID, content 1-1000 chars)
- [ ] Returns `{ error }` if user is not authenticated
- [ ] Returns `{ error }` if user is banned (`is_banned = true`)
- [ ] Returns `{ error }` if report's `comments_locked` is true
- [ ] Successfully inserts comment into `comments` table with report_id, user_id, content
- [ ] Calls `award_points` with 5 points for 'comment' action
- [ ] Calls `update_streak` for the commenting user
- [ ] Calls `check_and_award_badges` for the commenting user
- [ ] Calls `notify_followers` with 'new_comment' type, excluding the commenter
- [ ] Calls `revalidatePath` for the report detail page
- [ ] Returns `{ success: true }` on successful comment creation
- [ ] File uses 'use server' directive
- [ ] All errors return `{ error }` objects, never thrown exceptions
