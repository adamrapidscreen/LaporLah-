# E9-S5: Implement Admin Server Actions

## Description
Create all admin server actions for content moderation and dashboard statistics. Every action requires admin role verification before executing. Actions include hiding/unhiding reports, locking/unlocking comments, banning/unbanning users, and fetching admin statistics and flagged items.

## Dependencies
- Stories: E1-S2 (database tables/schema), E1-S3 (Supabase auth)
- Files: `src/lib/supabase/server.ts`

## Tasks
1. `src/lib/actions/admin.ts`: Create server actions file with 'use server' directive containing:
   - `hideReport(reportId: string)`: Set `is_hidden = true` on reports table, revalidate paths
   - `unhideReport(reportId: string)`: Set `is_hidden = false` on reports table, revalidate paths
   - `lockComments(reportId: string)`: Set `comments_locked = true` on reports table, revalidate paths
   - `unlockComments(reportId: string)`: Set `comments_locked = false` on reports table, revalidate paths
   - `banUser(userId: string)`: Set `is_banned = true` on users table, revalidate paths
   - `unbanUser(userId: string)`: Set `is_banned = false` on users table, revalidate paths
   - `getAdminStats()`: Query report counts by status, flagged items count, return `AdminStats` object
   - `getFlaggedItems()`: Query flags table joined with reports/comments, group by flagged item, return `FlaggedItem[]`
2. `src/lib/validations/admin.ts`: Create Zod schemas for admin action inputs (reportId, userId)
3. Helper function `requireAdmin()`: reusable auth + admin role check that throws or returns user

## Implementation Notes

### Admin Actions File
```typescript
// src/lib/actions/admin.ts
'use server';

import { createServerClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';

const idSchema = z.string().uuid();

async function requireAdmin() {
  const supabase = await createServerClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) return { error: 'Not authenticated', supabase: null, user: null };

  const { data: profile } = await supabase
    .from('users')
    .select('role')
    .eq('id', user.id)
    .single();

  if (profile?.role !== 'admin') return { error: 'Not authorized', supabase: null, user: null };

  return { error: null, supabase, user };
}

export async function hideReport(reportId: string) {
  const parsed = idSchema.safeParse(reportId);
  if (!parsed.success) return { error: 'Invalid report ID' };

  const { error: authError, supabase } = await requireAdmin();
  if (authError || !supabase) return { error: authError };

  const { error } = await supabase
    .from('reports')
    .update({ is_hidden: true })
    .eq('id', parsed.data);

  if (error) return { error: 'Failed to hide report' };

  revalidatePath('/admin/flagged');
  revalidatePath('/');
  return { error: null };
}

export async function unhideReport(reportId: string) {
  const parsed = idSchema.safeParse(reportId);
  if (!parsed.success) return { error: 'Invalid report ID' };

  const { error: authError, supabase } = await requireAdmin();
  if (authError || !supabase) return { error: authError };

  const { error } = await supabase
    .from('reports')
    .update({ is_hidden: false })
    .eq('id', parsed.data);

  if (error) return { error: 'Failed to unhide report' };

  revalidatePath('/admin/flagged');
  revalidatePath('/');
  return { error: null };
}

export async function lockComments(reportId: string) {
  // Same pattern: validate, requireAdmin, update comments_locked = true
}

export async function unlockComments(reportId: string) {
  // Same pattern: validate, requireAdmin, update comments_locked = false
}

export async function banUser(userId: string) {
  // Same pattern: validate, requireAdmin, update is_banned = true
}

export async function unbanUser(userId: string) {
  // Same pattern: validate, requireAdmin, update is_banned = false
}
```

### getAdminStats
```typescript
export async function getAdminStats(): Promise<AdminStats> {
  const { error: authError, supabase } = await requireAdmin();
  if (authError || !supabase) throw new Error(authError ?? 'Unauthorized');

  const { count: totalReports } = await supabase
    .from('reports').select('*', { count: 'exact', head: true });

  const { count: open } = await supabase
    .from('reports').select('*', { count: 'exact', head: true }).eq('status', 'open');

  const { count: acknowledged } = await supabase
    .from('reports').select('*', { count: 'exact', head: true }).eq('status', 'acknowledged');

  const { count: inProgress } = await supabase
    .from('reports').select('*', { count: 'exact', head: true }).eq('status', 'in_progress');

  const { count: resolved } = await supabase
    .from('reports').select('*', { count: 'exact', head: true }).eq('status', 'resolved');

  const { count: closed } = await supabase
    .from('reports').select('*', { count: 'exact', head: true }).eq('status', 'closed');

  const { count: flaggedCount } = await supabase
    .from('flags').select('*', { count: 'exact', head: true });

  return {
    totalReports: totalReports ?? 0,
    open: open ?? 0,
    acknowledged: acknowledged ?? 0,
    inProgress: inProgress ?? 0,
    resolved: resolved ?? 0,
    closed: closed ?? 0,
    flaggedCount: flaggedCount ?? 0,
  };
}
```

### getFlaggedItems
```typescript
export async function getFlaggedItems(): Promise<FlaggedItem[]> {
  const { error: authError, supabase } = await requireAdmin();
  if (authError || !supabase) throw new Error(authError ?? 'Unauthorized');

  const { data: flags } = await supabase
    .from('flags')
    .select(`
      id, reason, created_at,
      report:reports(id, title, is_hidden, comments_locked),
      comment:comments(id, body)
    `)
    .order('created_at', { ascending: false });

  // Group flags by report_id or comment_id, aggregate counts and reasons
  // Return array of FlaggedItem objects
}
```

### Types
```typescript
interface AdminStats {
  totalReports: number;
  open: number;
  acknowledged: number;
  inProgress: number;
  resolved: number;
  closed: number;
  flaggedCount: number;
}

interface FlaggedItem {
  id: string;
  type: 'report' | 'comment';
  reportId: string;
  title: string;
  flagCount: number;
  reasons: string[];
  isHidden: boolean;
  commentsLocked: boolean;
  createdAt: string;
}
```

## Acceptance Criteria
- [ ] All actions are in a single file with 'use server' directive
- [ ] Every action validates input with Zod (`z.string().uuid()`)
- [ ] Every action checks admin role via `requireAdmin()` before proceeding
- [ ] `hideReport` sets `is_hidden = true` and revalidates paths
- [ ] `unhideReport` sets `is_hidden = false` and revalidates paths
- [ ] `lockComments` sets `comments_locked = true` and revalidates paths
- [ ] `unlockComments` sets `comments_locked = false` and revalidates paths
- [ ] `banUser` sets `is_banned = true` and revalidates paths
- [ ] `unbanUser` sets `is_banned = false` and revalidates paths
- [ ] `getAdminStats` returns counts for all statuses and flagged items
- [ ] `getFlaggedItems` returns grouped flagged items with counts and reasons
- [ ] All actions return `{ error: string | null }` on mutation operations
- [ ] Failed auth returns `{ error }` instead of throwing
