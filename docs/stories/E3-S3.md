# E3-S3: Build Location Picker Component

## Description
Build a location picker component using Leaflet and React-Leaflet that requests the user's geolocation, displays a mini-map with a draggable pin, and reverse-geocodes the selected coordinates via Nominatim. Also create the geocoding utility and geolocation hook. The component must be dynamically imported with `ssr: false` since Leaflet requires the DOM.

## Dependencies
- Stories: E1-S1 (leaflet packages installed)
- Files: `package.json` (leaflet, react-leaflet, @types/leaflet)

## Tasks
1. `src/components/map/location-picker.tsx`: Create Client Component with Leaflet map, draggable marker, current location button, reverse geocode on marker move. Must be dynamically imported with `ssr: false`
2. `src/lib/utils/geocoding.ts`: Create reverse geocoding utility using Nominatim API (free, no API key required)
3. `src/lib/hooks/use-geolocation.ts`: Create custom hook for browser Geolocation API with loading/error states

## Implementation Notes

### Location Picker (`src/components/map/location-picker.tsx`)
```typescript
'use client';

import { useState, useCallback, useEffect } from 'react';
import { MapContainer, TileLayer, Marker, useMapEvents } from 'react-leaflet';
import L from 'leaflet';
import { MapPin, Crosshair } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { reverseGeocode } from '@/lib/utils/geocoding';
import { useGeolocation } from '@/lib/hooks/use-geolocation';

import 'leaflet/dist/leaflet.css';

interface LocationPickerProps {
  onLocationSelect: (location: {
    latitude: number;
    longitude: number;
    area_name: string;
  }) => void;
}

// Default: Kuala Lumpur
const DEFAULT_CENTER: [number, number] = [3.139, 101.6869];
const DEFAULT_ZOOM = 15;

// Fix Leaflet default icon issue with bundlers
const markerIcon = new L.Icon({
  iconUrl: '/icons/marker-icon.png',
  iconRetinaUrl: '/icons/marker-icon-2x.png',
  shadowUrl: '/icons/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41],
});

function DraggableMarker({
  position,
  onMove,
}: {
  position: [number, number];
  onMove: (lat: number, lng: number) => void;
}) {
  const eventHandlers = {
    dragend(e: L.DragEndEvent) {
      const marker = e.target;
      const pos = marker.getLatLng();
      onMove(pos.lat, pos.lng);
    },
  };

  return <Marker position={position} draggable icon={markerIcon} eventHandlers={eventHandlers} />;
}

export function LocationPicker({ onLocationSelect }: LocationPickerProps) {
  const { latitude, longitude, loading, error, requestLocation } = useGeolocation();
  const [position, setPosition] = useState<[number, number]>(DEFAULT_CENTER);
  const [areaName, setAreaName] = useState<string>('');

  useEffect(() => {
    if (latitude && longitude) {
      setPosition([latitude, longitude]);
      handleGeocode(latitude, longitude);
    }
  }, [latitude, longitude]);

  const handleGeocode = useCallback(async (lat: number, lng: number) => {
    const name = await reverseGeocode(lat, lng);
    setAreaName(name);
    onLocationSelect({ latitude: lat, longitude: lng, area_name: name });
  }, [onLocationSelect]);

  const handleMarkerMove = (lat: number, lng: number) => {
    setPosition([lat, lng]);
    handleGeocode(lat, lng);
  };

  return (
    <div className="space-y-2">
      <label className="text-sm font-medium">Location</label>
      <div className="relative rounded-lg overflow-hidden border border-border">
        <MapContainer
          center={position}
          zoom={DEFAULT_ZOOM}
          className="h-48 w-full z-0"
          scrollWheelZoom={false}
        >
          <TileLayer
            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          />
          <DraggableMarker position={position} onMove={handleMarkerMove} />
        </MapContainer>

        <Button
          type="button"
          variant="secondary"
          size="icon"
          className="absolute bottom-2 right-2 z-10 h-8 w-8"
          onClick={requestLocation}
          disabled={loading}
        >
          <Crosshair className="h-4 w-4" />
        </Button>
      </div>

      {areaName && (
        <p className="flex items-center gap-1 text-sm text-muted-foreground">
          <MapPin className="h-3.5 w-3.5" />
          {areaName}
        </p>
      )}
      {error && <p className="text-sm text-destructive">{error}</p>}
    </div>
  );
}
```

### Dynamic Import Pattern (in parent page/form)
```typescript
import dynamic from 'next/dynamic';

const LocationPicker = dynamic(
  () => import('@/components/map/location-picker').then((mod) => mod.LocationPicker),
  { ssr: false, loading: () => <div className="h-48 rounded-lg bg-muted animate-pulse" /> }
);
```

### Reverse Geocoding (`src/lib/utils/geocoding.ts`)
```typescript
interface NominatimResponse {
  display_name: string;
  address: {
    road?: string;
    suburb?: string;
    city?: string;
    state?: string;
    country?: string;
  };
}

export async function reverseGeocode(lat: number, lng: number): Promise<string> {
  try {
    const response = await fetch(
      `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=16&addressdetails=1`,
      {
        headers: { 'User-Agent': 'LaporLah/1.0' },
      }
    );

    if (!response.ok) throw new Error('Geocode failed');

    const data: NominatimResponse = await response.json();
    const { road, suburb, city } = data.address;

    // Build a concise area name
    const parts = [road, suburb, city].filter(Boolean);
    return parts.join(', ') || data.display_name;
  } catch {
    return 'Unknown location';
  }
}
```

### Geolocation Hook (`src/lib/hooks/use-geolocation.ts`)
```typescript
'use client';

import { useState, useCallback } from 'react';

interface GeolocationState {
  latitude: number | null;
  longitude: number | null;
  loading: boolean;
  error: string | null;
}

export function useGeolocation() {
  const [state, setState] = useState<GeolocationState>({
    latitude: null,
    longitude: null,
    loading: false,
    error: null,
  });

  const requestLocation = useCallback(() => {
    if (!navigator.geolocation) {
      setState((prev) => ({ ...prev, error: 'Geolocation not supported' }));
      return;
    }

    setState((prev) => ({ ...prev, loading: true, error: null }));

    navigator.geolocation.getCurrentPosition(
      (position) => {
        setState({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          loading: false,
          error: null,
        });
      },
      (error) => {
        setState((prev) => ({
          ...prev,
          loading: false,
          error: error.message,
        }));
      },
      { enableHighAccuracy: true, timeout: 10000 }
    );
  }, []);

  return { ...state, requestLocation };
}
```

## Acceptance Criteria
- [ ] Map renders with OpenStreetMap tiles centered on Kuala Lumpur by default
- [ ] "Locate me" button requests browser geolocation and centers map on user's position
- [ ] Marker is draggable â€” user can adjust pin location
- [ ] Moving the marker triggers reverse geocoding via Nominatim
- [ ] Area name displays below the map (e.g., "Jalan Bukit Bintang, Bukit Bintang, Kuala Lumpur")
- [ ] `onLocationSelect` callback fires with `{ latitude, longitude, area_name }`
- [ ] Component is dynamically imported with `ssr: false` (Leaflet requires DOM)
- [ ] SSR loading fallback shows a shimmer placeholder (`h-48 bg-muted animate-pulse`)
- [ ] Geolocation errors display as `text-destructive` message
- [ ] `useGeolocation` hook returns `{ latitude, longitude, loading, error, requestLocation }`
- [ ] Nominatim requests include `User-Agent: LaporLah/1.0` header
- [ ] Named exports: `LocationPicker`, `reverseGeocode`, `useGeolocation`
