# E7-S2: Implement castVote Server Action

## Description
Create the `castVote` server action that handles community confirmation voting. The action validates authentication, enforces one-vote-per-user-per-report via the UNIQUE constraint, inserts into the confirmations table, awards points for voting, triggers the resolution check, and revalidates the report detail page cache.

## Dependencies
- Stories: E7-S1 (vote panel component), E1-S2 (confirmations table with UNIQUE constraint, DB functions)
- Files: `src/components/confirmation/vote-panel.tsx`, `supabase/migrations/001_create_tables.sql`

## Tasks
1. `src/lib/actions/votes.ts`: Create server action file with:
   - `castVote(reportId: string, vote: 'confirmed' | 'not_yet')` — validates auth via `createServerClient()`, validates input with Zod schema, checks report exists and status is 'resolved', INSERTs into `confirmations` table (relies on UNIQUE(user_id, report_id) for duplicate prevention), calls `award_points(userId, 'confirmation_vote', 8, reportId)` via Supabase RPC, calls `checkResolution(reportId)` after successful insert, calls `revalidatePath('/report/[id]')`.
   - Return `{ error: string }` on failure, `{ success: true }` on success.

## Implementation Notes

### Server Action Structure
```ts
// src/lib/actions/votes.ts
'use server';

import { createServerClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';

const castVoteSchema = z.object({
  reportId: z.string().uuid(),
  vote: z.enum(['confirmed', 'not_yet']),
});

export async function castVote(reportId: string, vote: 'confirmed' | 'not_yet') {
  const parsed = castVoteSchema.safeParse({ reportId, vote });
  if (!parsed.success) return { error: 'Invalid input' };

  const supabase = await createServerClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { error: 'Not authenticated' };

  // Verify report exists and is in 'resolved' status
  const { data: report } = await supabase
    .from('reports')
    .select('id, status, creator_id')
    .eq('id', reportId)
    .single();

  if (!report) return { error: 'Report not found' };
  if (report.status !== 'resolved') return { error: 'Report is not in resolved status' };

  // Insert vote (UNIQUE constraint prevents duplicates)
  const { error: insertError } = await supabase
    .from('confirmations')
    .insert({
      report_id: reportId,
      user_id: user.id,
      vote,
    });

  if (insertError) {
    if (insertError.code === '23505') return { error: 'You have already voted' };
    return { error: 'Failed to cast vote' };
  }

  // Award points for voting
  await supabase.rpc('award_points', {
    p_user_id: user.id,
    p_action: 'confirmation_vote',
    p_points: 8,
    p_report_id: reportId,
  });

  // Check resolution thresholds
  await checkResolution(reportId);

  revalidatePath(`/report/${reportId}`);
  return { success: true };
}
```

### Validation Pattern
- Use Zod for input validation (per coding standards)
- Check auth with `supabase.auth.getUser()`
- Return `{ error }` objects on failure (never throw)
- Rely on DB UNIQUE constraint `UNIQUE(user_id, report_id)` for duplicate prevention — catch PostgreSQL error code `23505`

### Points Integration
- Call `award_points` RPC with action `'confirmation_vote'` and 8 points
- Points are awarded regardless of vote direction (confirmed or not_yet)

## Acceptance Criteria
- [ ] `castVote` server action is exported from `src/lib/actions/votes.ts`
- [ ] Input is validated with Zod (reportId must be UUID, vote must be 'confirmed' or 'not_yet')
- [ ] Unauthenticated users receive `{ error: 'Not authenticated' }`
- [ ] Voting on a non-resolved report returns an error
- [ ] Duplicate votes are caught via UNIQUE constraint (error code 23505)
- [ ] Successful vote inserts row into `confirmations` table
- [ ] 8 points are awarded to the voter via `award_points` RPC
- [ ] `checkResolution` is called after successful vote insert
- [ ] `revalidatePath` is called to refresh the report detail page
- [ ] All errors return `{ error: string }` format (no thrown exceptions)
